%{
	#include <stdio.h>
	#include <iostream>
	#include "LLVM_generator.hpp"
	#include "hw3_output.hpp"
	
	

	
	int yylex();
	void yyerror(const char*);
	extern int yylineno;
	
	using namespace std;
	using namespace output;
	
	Symbol_Table symbolTable = Symbol_Table();
	Function* curFunc;
	Enum_class* curEnumClass;
	stack<vector<Node*>> ParamListStack = stack<vector<Node*>>();
	Genreator a = Genreator();
	vector<Node*> args = vector<Node*>(); // this is for call
	
	
	

%}




%token  VOID INT BYTE B BOOL ENUM TRUE FALSE RETURN ELSE WHILE BREAK CONTINUE SC COMMA LBRACE RBRACE ID NUM STRING
%right ASSIGN
%left OR
%left AND
%left EQUALOP
%left RELATIONOP
%left ADDOPS
%left MULTOPS
%right LPAREN RPAREN
%right IF ELSE
%right NOT


%%

Program : 		Enums Funcs 										
						{};


Funcs :			/*epsilon*/ 													
						{}
				| FuncDecl Funcs 													
						{};



FuncDecl :		RetType ID  {
							Variable* var = symbolTable.getVar($2->name);
							Variable* var_as_class = symbolTable.getVar("enum "+$2->name);
							if(var != nullptr || symbolTable.isThereEnumContains($2->name) || var_as_class != nullptr){
							
								errorDef(yylineno, $2->name);
								delete $1;
								delete $2;
								exit(0);
							}
						
							curFunc = new Function($2->name,$1->type);
							$2->type = FUNCTION_t;
							
						} LPAREN Formals RPAREN LBRACE 
						{
					
						symbolTable.insertFunc(curFunc);
						
			
						
					
						vector<string> string_prms = TypeToLvmTypes(curFunc->paramTypes);
						string return_as_string = TokenTypeToLlvmType(curFunc->returnType);
						
						a.funcDecGen($2->name ,return_as_string , string_prms, curFunc->params);
						
						
						}
						Statements RBRACE 
						{	
							
							CodeBuffer::instance().emit("}");
							a.clear_regs();
							symbolTable.closeScope();
							delete $1;
							delete $2;
							
						
						
						}
						;
//TODO: find out how the fuck to make Enum in llvm
Enums :			/*epsilon*/ 															
						{}
				| EnumDecl Enums 													
						{};

EnumDecl :		ENUM ID {
							Variable* var = symbolTable.getVar($2->name);
							Variable* var_as_class = symbolTable.getVar("enum "+$2->name);
							if(var != nullptr || symbolTable.isThereEnumContains($2->name) || var_as_class != nullptr){
							
								errorDef(yylineno, $2->name);
								
								delete $2;
								exit(0);
							}
							
							
							curEnumClass = new Enum_class("enum " + $2->name);
							delete $2;
							
						} LBRACE EnumeratorList RBRACE SC 	
							
						{symbolTable.insertVar(curEnumClass);};

RetType :		Type 														
						{$$ = $1;}
				| VOID 																
						{$$ = new Node(VOID_t);};

Formals :		/*epsilon*/ 												
						{}
				| FormalsList 														
						{};

FormalsList :	FormalDecl 													
						{}
				| FormalDecl COMMA FormalsList 									
						{};

FormalDecl :	Type ID 													
						{
							
							Variable* var = symbolTable.getVar($2->name);
							Variable* var_as_class = symbolTable.getVar("enum "+$2->name);
							if(var != nullptr || symbolTable.isThereEnumContains($2->name) || var_as_class != nullptr){
							
								errorDef(yylineno, $2->name);
								
								delete $2;
								exit(0);
							}
							Variable* allocated_param = new Variable($1->type,$2->name);
							allocated_param->reg = a.RegAlloc();
							curFunc->addParam(allocated_param);
							$2->type = $1->type;
						
						}
				| EnumType ID 														
						{
						
							Variable* var = symbolTable.getVar($2->name);
							Variable* var_as_class = symbolTable.getVar("enum "+$2->name);
							if(var != nullptr || symbolTable.isThereEnumContains($2->name) || var_as_class != nullptr){
							
								errorDef(yylineno, $2->name);
								
								delete $2;
								exit(0);
							}
							auto tmp = (Enum_class*)$1;
							if(!symbolTable.CheckIfEnumInGlobalScope(tmp)){
							errorUndef(yylineno,$1->name);
							delete $1;
							exit(0);
							}
							curFunc->addParam(new Enum_var(ENUM_t, (Enum_class*) $1, $2->name,0,""));
							$2->type = $1->type;
						
						};


EnumeratorList :	Enumerator 											
						{
						
						}
				| EnumeratorList COMMA Enumerator 									
						{};

Enumerator :		ID 															
						{
						
							Variable* var = symbolTable.getVar($1->name);
						
							Variable* var_as_class = symbolTable.getVar("enum "+$1->name);


							
							if(var != nullptr || symbolTable.isThereEnumContains($1->name) || var_as_class != nullptr || curEnumClass->contains($1->name) || "enum " + $1->name == curEnumClass->name){
					
								errorDef(yylineno, $1->name);
								delete $1;
								exit(0);
							}
							
							
						curEnumClass->enum_vals.push_back($1->name);
						  delete $1;
						 
						};

Statements :	Statement 													
						{}
				| Statements Statement 												
						{};

Statement :		LBRACE OPENORMAL Statements RBRACE CLOSE
				| Type ID SC 														

						{	
						
							Variable* var = symbolTable.getVar($2->name);
							Variable* var_as_class = symbolTable.getVar("enum "+$2->name);
							if(var != nullptr || symbolTable.isThereEnumContains($2->name) || var_as_class != nullptr){
							
								errorDef(yylineno, $2->name);
								delete $1;
								delete $2;
								exit(0);
							}
							var = new Variable($1->type,$2->name);
							int size = symbolTable.scopes_table.size();
							var->reg = a.Var_Alloc(var->type);
							symbolTable.insertVar(var);
							

							delete $1;
							delete $2;
						}
				| EnumType ID  SC 													
						{
						
						Variable* var = symbolTable.getVar($2->name);
							Variable* var_as_class = symbolTable.getVar("enum "+$2->name);
							if(var != nullptr || symbolTable.isThereEnumContains($2->name) || var_as_class != nullptr){
							
								errorDef(yylineno, $2->name);
								delete $1;
								delete $2;
								exit(0);
							}
							//check here abut value
							var = new Enum_var(ENUM_t, (Enum_class*) $1  , $2->name,0,"");
							
							symbolTable.insertVar(var);
							var->reg = a.Var_Alloc();

							delete $2;
						
						
						}
				| EnumDecl 															
		
						{}
				| Type ID ASSIGN Exp SC 											
						{
							
							
							Variable* var = symbolTable.getVar($2->name);
							Variable* var_as_class = symbolTable.getVar("enum "+$2->name);
							if(var != nullptr || symbolTable.isThereEnumContains($2->name) || var_as_class != nullptr){
							
								errorDef(yylineno, $2->name);
								
								exit(0);
							}
							
							if($1->type != $4->type && (!($1->type == INT_t  && $4->type == BYTE_t  )) && $4->type != FUNCTION_t )
							{
							
							
								errorMismatch(yylineno);
								
								exit(0);
							}
							
							//check if exp is call func
							if ($4->type == FUNCTION_t){
								
								Function* f = (Function*)$4;
								if($1->type != f->returnType && (!($1->type == INT_t  && f->returnType == BYTE_t  )) ){
									errorMismatch(yylineno);
									exit(0);
									}
								
							}
							
							
							var = new Variable($1->type,$2->name);
							var->reg = a.Var_Alloc(var->type);
							if ($4->type != FUNCTION_t)
								a.Var_Alloc_And_Assign(var->reg,$1->type,$4);
							else{
								a.Var_Alloc_And_Assign(var->reg,$1->type,$4,&args);
							}
							symbolTable.insertVar(var);
							

							
							
						}
				| EnumType ID ASSIGN Exp { 
							
							Variable* var = symbolTable.getVar($2->name);
							Variable* var_as_class = symbolTable.getVar("enum "+$2->name);
							if(var != nullptr || symbolTable.isThereEnumContains($2->name) || var_as_class != nullptr){
							
								errorDef(yylineno, $2->name);
								delete $1;
								delete $2;
								delete $4;
								exit(0);
							}
								
								auto tmp = (Enum_class*)$1;
								auto var_to_assign =symbolTable.getVar($4->name);
								if ((! tmp->contains($4->name)) && !(tmp->contains(var_to_assign->value))   ){
								
									cout << "tmp->name = " << tmp->name << "  , $4->name = " << $4->name  << "  v_t_a->value = "<< var_to_assign->value << endl;
									errorUndefEnumValue(yylineno,$2->name);
									delete $2;
											
									exit(0);		
								
								}
								//TODO: check if exp is function
								$2->reg  = a.Var_Alloc();
								a.Var_Alloc_And_Assign($2->reg ,INT_t,$4,nullptr);
								
							}
				SC{
								Enum_var* new_var = new Enum_var(ENUM_t, (Enum_class*) $1   ,$2->name,0,$4->value);
										symbolTable.insertVar(new_var);
										
										delete $2;
										
				}	
				| ID ASSIGN Exp SC 													
						{
						
							Variable* var = symbolTable.getVar($1->name);
							if(var == nullptr || var->type == FUNCTION_t ){
								
								errorUndef(yylineno, $2->name);
								delete $1;
								
								exit(0);
							}
							
							if( var->type !=ENUM_t && $3->type != FUNCTION_t && (var->type != $3->type) && (var->type != INT_t && $3->type != BYTE_t)){
						
								errorMismatch(yylineno);
								delete $1;
								
								exit(0);
							}
							//check if exp is call func
							if ($3->type == FUNCTION_t){
								
								Function* f = (Function*)symbolTable.getVar($3->name);
								if(var->type != f->returnType && (!(var->type == INT_t  && f->returnType == BYTE_t  )) ){
								errorMismatch(yylineno);
								exit(0);
								}
								
							}
							if(var->type == ENUM_t && ($3->type == ENUM_t || $3->type == INT_t || $3->type == BYTE_t || $3->type == BOOL_t|| $3->type == STRING_t || $3->type == VOID_t)){
								auto tmp = (Enum_var*)var;
								auto tmp_class = (Enum_class*)symbolTable.getVar(tmp->enum_type);
								auto var_to_assign =symbolTable.getVar($3->name);
								if (tmp_class == nullptr || (!tmp_class->contains($3->name)   &&  !(tmp_class->contains(var_to_assign->value))  )){
									errorUndefEnumValue(yylineno,var->name);
									exit(0);
								}
							}
								var->value = $3->value;
								//CodeBuffer::instance().emit("name is " + var->name + "value is " + var->value + "reg is " + var->reg);
							//the name of the func says alloc, but don't worry it doesn't alloc anything
							if ($3->type == FUNCTION_t)
								a.Var_Alloc_And_Assign(var->reg,var->type,$3,&args);
							else if($3->type == ENUM_t){
								
							//	Enum_class* tmp = symbolTable.FindEnumContains($3->value);
								//idk why but it is working
								var->reg = a.Var_Alloc();
								a.Var_Alloc_And_Assign(var->reg ,INT_t,$3,nullptr);
								
							}else
								a.Var_Alloc_And_Assign(var->reg,var->type,$3);
								
							
							
							

							delete $1;
							
						}
				| Call SC 															
						{
						Function* callee = (Function*)$1;
						a.genCall(callee->name,callee->returnType,callee->paramTypes,args,true);}
				| RETURN SC 														
						{
							auto& scope = symbolTable.scopes_table[symbolTable.scopes_table.size()-1 < 0 ? 0 : symbolTable.scopes_table.size()-1 ];
							assert(scope.curFunc != nullptr);//grammar makes sure
							auto f = scope.curFunc;
							if(f->returnType != VOID_t){
								errorMismatch(yylineno);
								exit(0);
							}
							
							a.genReturn(VOID_t);
						}
				| RETURN Exp SC 													
						{
							auto& scope = symbolTable.scopes_table[symbolTable.scopes_table.size()-1 < 0 ? 0 : symbolTable.scopes_table.size()-1];
							assert(scope.curFunc != nullptr);//grammar makes sure
							auto f = scope.curFunc;
							if($2->type != FUNCTION_t && (f->returnType != $2->type || $2->type == VOID_t) && !(f->returnType == INT_t && $2->type == BYTE_t) ){
								errorMismatch(yylineno);
								delete $2;
								exit(0);
							}
							
							
							
							//check if exp is call func
							if ($2->type == FUNCTION_t){
								
								Function* exp_f = (Function*)$2;
								if(f->returnType != exp_f->returnType && (!(f->returnType == INT_t  && exp_f->returnType == BYTE_t  )) ){
								errorMismatch(yylineno);
								exit(0);
								}
								
							}
							
							
							if ($2->type == FUNCTION_t){
								Function* tmp_f = (Function*)$2;
								a.genReturn(tmp_f->returnType , $2);
							}else{
								a.genReturn($2->type , $2);
							}
							
						}
				| IF LPAREN checkBoolExp RPAREN OPENORMAL Statement CLOSE  									
						{
						}
				| IF LPAREN checkBoolExp   RPAREN OPENORMAL
							
							Statement CLOSE
							ELSE OPENORMAL
						
							Statement CLOSE
						{}
				| WHILE LPAREN checkBoolExp 
				{
					
					 symbolTable.openScope(LOOP);
				} RPAREN  Statement 									
						{
							symbolTable.closeScope();
						 }
				| BREAK SC 															
						{
							auto& scope = symbolTable.scopes_table[symbolTable.scopes_table.size()-1 < 0 ? 0 : symbolTable.scopes_table.size()-1];
							if(!scope.isLoop){
								errorUnexpectedBreak(yylineno);
								exit(0);
							}
						}
				| CONTINUE SC 														
						{
							auto& scope = symbolTable.scopes_table[symbolTable.scopes_table.size()-1 < 0 ? 0 : symbolTable.scopes_table.size()-1];
							if(!scope.isLoop){
								errorUnexpectedContinue(yylineno);
								exit(0);
							}
						};
checkBoolExp :     Exp {
				
						if($1->type != BOOL_t)
						{
							errorMismatch(yylineno);
							exit(0);
						}
					}
Call :			ID LPAREN {ParamListStack.push(vector<Node*>()); } ExpList RPAREN 										
						{
						
							Function* callee = (Function*)symbolTable.getVar($1->name);
							auto& vec = ParamListStack.top();

							if (callee == nullptr || callee->type != FUNCTION_t){
								
								errorUndefFunc(yylineno, $1->name);
								ParamListStack.pop();
								delete $1;
								exit(0);
							}
							delete $1;
							
							callee->ValidateParameters(vec,symbolTable);
							//callee->reg = callee->reg == "" ? a.RegAlloc() : callee->reg;
							$$ = callee;	
							args = vec;
							ParamListStack.pop();
							
						}

				| ID LPAREN RPAREN 													
						{	
							Function* callee = (Function*)symbolTable.getVar($1->name);
							auto vec = vector<Node*>();
							if (callee == nullptr || callee->type != FUNCTION_t){
								
								errorUndefFunc(yylineno, $1->name);
								delete $1;
								exit(0);
							}

							delete $1;
							auto tmp = vector<Node*>();
							//callee->reg = callee->reg == "" ? a.RegAlloc() : callee->reg;
							callee->ValidateParameters(tmp,symbolTable);
							$$ = callee;
							args=vec;
							
							

						};

ExpList :		Exp 														
						{ParamListStack.top().push_back($1);}
				| Exp COMMA ExpList 												
						{ParamListStack.top().push_back($1);};

Type :			INT 															
						{
						
					
						$$ = new Node(INT_t);}
				| BYTE 																
						{$$ = new Node(BYTE_t);}
				| BOOL 																
						{
						
						$$ = new Node(BOOL_t);};

EnumType :		ENUM ID 													
						{Node* var = symbolTable.getVar("enum " + $2->name);
							if (var == nullptr){
								errorUndefEnum(yylineno, $2->name);
								delete $2;
								exit(0);
							}
							delete $2;
							$$ = var;
						};
						

Exp :			LPAREN Exp RPAREN 											
						{$$ = $2;}

				| Exp ADDOPS Exp 													
						{ if (($1->type != INT_t && $1->type !=BYTE_t) || ($3->type != INT_t && $3->type != BYTE_t)){
							errorMismatch(yylineno);
							delete $1;
							delete $3;
							exit(0);
						}
						if ($1->type == BYTE_t && $3->type == BYTE_t){
							
							$$ = new Node(BYTE_t);
							$$->reg = a.genAddOp($1->reg, $2->value , $3->reg , BYTE_t);
						}
						else{ 
							$$= new Node(INT_t);
							$$->reg = a.genAddOp($1->reg, $2->value , $3->reg , INT_t);
							}

						}
				| Exp MULTOPS Exp 													
						{ if (($1->type != INT_t && $1->type !=BYTE_t) || ($3->type != INT_t && $3->type != BYTE_t)){
							errorMismatch(yylineno);
							delete $1;
							delete $3;
							exit(0);
						}
						if ($1->type == BYTE_t && $3->type == BYTE_t){
							
							$$ = new Node(BYTE_t);
							$$->reg = a.genMultOp($1->reg, $2->value , $3->reg , BYTE_t);
						}
						else{ 
							$$= new Node(INT_t);
							$$->reg = a.genMultOp($1->reg, $2->value , $3->reg , INT_t);
							}

						}

				| ID 																
					{
					Variable* var = symbolTable.getVar($1->name);
							if(  var == nullptr ){
							
								if (!symbolTable.isThereEnumContains($1->name)){
								
								errorUndef(yylineno, $1->name);
								delete $1;
								exit(0);
								}
							}
							
						if (symbolTable.isThereEnumContains($1->name) && var == nullptr){

							auto tmp = symbolTable.FindEnumContains($1->name);//we know this isn't nullptr for sure
							$$ = new Enum_var(ENUM_t,  tmp,  $1->name,0,$1->name);
							
							//TODO: add emit code for enum case, if needed(im guessing yes needed)
						}
						else{
							$$ = var;
						}
						
						
					}

				| Call 																
					{
						
						$$ = $1;
					}

				| NUM 																
						{ 
						//no need here for Var_Alloc
						$$ = new Node(INT_t , $1->name , $1->value);
						
							delete $1;
						}

				| NUM B 														
					{	if( !( stoi($1->value) >= 0 && (stoi($1->value) <= 255))){
										
											errorByteTooLarge(yylineno, $1->value);
											delete $1;
											exit(0);
										}
						$$ = new Node(BYTE_t,$1->name,$1->value, $1->value);
						delete $1;

					}

				| STRING 															
						{
							$$ = new Node(STRING_t,$1->name,$1->name); 
							//might not need this anyways but TODO: no need to do emit code? emitGlobal? what the fuck?
						}

				| TRUE 																
						{$$ = new Node(BOOL_t,"","true");}

				| FALSE 															
						{$$ = new Node(BOOL_t,"","false");}
						
				| NOT Exp 															
						{
							if($2->type != BOOL_t){
									errorMismatch(yylineno);
									delete $2;
									exit(0);
							}
							
							$$ = new Node(BOOL_t , "" , $2->value == "false" ? "true" : "false");
							
						}


				| Exp AND Exp 														
						{
							if($1->type != BOOL_t || $3->type != BOOL_t){
									errorMismatch(yylineno);
									delete $1;
									delete $3;
									exit(0);
							}
							$$ = new Node(BOOL_t);
							

						}

				| Exp OR Exp 														
						{
							if($1->type != BOOL_t || $3->type != BOOL_t){
									errorMismatch(yylineno);
									delete $1;
									delete $3;
									exit(0);
							}
							$$ = new Node(BOOL_t);
							
						}

				| Exp RELATIONOP Exp 												
						{
							
							
							if( ($1->type != INT_t && $1->type != BYTE_t) || ($3->type != INT_t && $3->type != BYTE_t)){
									errorMismatch(yylineno);
									delete $1;
									delete $3;
									exit(0);
							}
							
							$$ = new Node(BOOL_t);
							
						}

				| Exp EQUALOP Exp 													
						{
							if(($1->type != INT_t && $1->type != BYTE_t) || ($3->type != INT_t && $3->type != BYTE_t)){
									errorMismatch(yylineno);
									delete $1;
									delete $3;
									exit(0);
							}
							$$ = new Node(BOOL_t);
							
						}

				| LPAREN Type RPAREN Exp 
				
						{	
						if ( $2->type != INT_t){
								delete $2;
								errorMismatch(yylineno);
								exit(0);
								}
						
							if($4->type != ENUM_t && !(symbolTable.isThereEnumContains($4->name))){
								delete $2;
								
								errorMismatch(yylineno);
								exit(0);
							}
							Node* enum_var = symbolTable.getVar($4->name);
							if (enum_var == nullptr && !(symbolTable.isThereEnumContains($4->name))){
								delete $2;
								
								errorUndef(yylineno,$4->name);
								exit(0);
							}
							
							auto enum_var_casted = enum_var==nullptr ? nullptr : (Enum_var*)enum_var; 
							string enum_var_name = enum_var==nullptr ? "" : enum_var_casted->name;
							int enum_var_offset = enum_var==nullptr ? 0 : enum_var_casted->offset; 
							string enum_var_value = enum_var==nullptr ? "" : enum_var_casted->value; 
							Variable* new_int = new Variable(INT_t,enum_var_name,enum_var_offset,enum_var_value);
							delete $2;
							$$ = new_int;
							
							
							//Enum_class* enum_class = symbolTable.FindEnumContains(enum_var->value);
							$$->reg = a.Var_Alloc();
							a.Var_Alloc_And_Assign($$->reg ,INT_t,enum_var,nullptr);
							
							
						};
						
						
OPENORMAL:					{symbolTable.openScope(NORMAL);};
CLOSE:						{symbolTable.closeScope();};


M:      				{
							$$ = new Node( UNDEFYET_t,"" ,"",   CodeBuffer::instance().genLabel());//saves the label of the next label to do
						}
MELSE:					{
						//this one makes sure the if we are in the if body (the if cond is true) and there is an else body, we use this to skip the else body
							$$ = new Node(UNDEFYET_t); 
							
							pair<int,BranchLabelIndex> p = pair<int,BranchLabelIndex> (CodeBuffer::instance().emit("goto @"), FIRST);
							$$->truelist = CodeBuffer::instance().makelist(p);
						}
%%



int main()
{

	symbolTable.openScope(GLOBAL);
	curFunc = new Function("print", VOID_t);
	Variable* dummy = new Variable(STRING_t);
	curFunc->addParam(dummy);
	symbolTable.insertFunc(curFunc);
	symbolTable.scopes_table.pop_back();
	symbolTable.offset_stack.pop();
	
	curFunc = new Function("printi", VOID_t);
	dummy = new Variable(INT_t,"");
	curFunc->addParam(dummy);
	symbolTable.insertFunc(curFunc);
	symbolTable.scopes_table.pop_back();
	symbolTable.offset_stack.pop();
	a.Gen_Printers();
	
	yyparse();
	
	
	
	/*checking if main exsists*/
	Function* main_func = (Function*)symbolTable.getVar("main");
	if (main_func == nullptr || main_func->type != FUNCTION_t || main_func->paramTypes.size()!= 0 || main_func->returnType != VOID_t){
		errorMainMissing();
		return 0;
	}
	
	symbolTable.closeScope();
	CodeBuffer::instance().printCodeBuffer();

	

    return 0;
}

void yyerror(char const* error){
	errorSyn(yylineno);
	exit(0);
}





