%{
	#include <stdio.h>
	#include <iostream>
	#include "LLVM_generator.hpp"
	#include "hw3_output.hpp"
	
	

	
	int yylex();
	void yyerror(const char*);
	extern int yylineno;
	
	using namespace std;
	using namespace output;
	
	Symbol_Table symbolTable = Symbol_Table();
	Function* curFunc;
	Enum_class* curEnumClass;
	stack<vector<Node*>> ParamListStack = stack<vector<Node*>>();
	Genreator a = Genreator();
	vector<Node*> args = vector<Node*>(); // this is for call
	bool return_flag = true;
	
	
		//these are for if, and loops and shit like that
	stack<int> last_br_emit;
	stack<int> last_while_emit;
	stack< pair<int,BranchLabelIndex> > last_MELSE = stack< pair<int,BranchLabelIndex> >();//this is not technecacly needed but this parser is an idiot, (or we are, meh :) )
	stack< vector< pair<int,BranchLabelIndex>> > Break_labels = stack<vector< pair<int,BranchLabelIndex> >>();
	stack< vector< pair<int,BranchLabelIndex>> > Cont_labels = stack<vector< pair<int,BranchLabelIndex> >>();
	Node* last_bool_exp = nullptr;
	

%}




%token  VOID INT BYTE B BOOL ENUM TRUE FALSE RETURN ELSE WHILE BREAK CONTINUE SC COMMA LBRACE RBRACE ID NUM STRING
%right ASSIGN
%left OR
%left AND
%left EQUALOP
%left RELATIONOP
%left ADDOPS
%left MULTOPS
%right LPAREN RPAREN
%right IF ELSE
%right NOT


%%

Program : 		Enums Funcs 										
						{};


Funcs :			/*epsilon*/ 													
						{}
				| FuncDecl Funcs 													
						{};



FuncDecl :		RetType ID  {
							return_flag = true;
							Variable* var = symbolTable.getVar($2->name);
							Variable* var_as_class = symbolTable.getVar("enum "+$2->name);
							if(var != nullptr || symbolTable.isThereEnumContains($2->name) || var_as_class != nullptr){
							
								errorDef(yylineno, $2->name);
								delete $1;
								delete $2;
								exit(0);
							}
						
							curFunc = new Function($2->name,$1->type);
							$2->type = FUNCTION_t;
							
						} LPAREN Formals RPAREN LBRACE 
						{
					
						symbolTable.insertFunc(curFunc);
						
			
						
					
						vector<string> string_prms = TypeToLvmTypes(curFunc->paramTypes);
						string return_as_string = TokenTypeToLlvmType(curFunc->returnType);
						
						a.funcDecGen($2->name ,return_as_string , string_prms, curFunc->params);
						
						
						}
						Statements {
							if (return_flag){
								a.genReturn(curFunc);
							}
							} RBRACE 
						{	
							
							CodeBuffer::instance().emit("}");
							a.clear_regs();
							symbolTable.closeScope();
							delete $1;
							delete $2;
							
							
							
						
						
						}
						;
//TODO: find out how the fuck to make Enum in llvm
Enums :			/*epsilon*/ 															
						{}
				| EnumDecl Enums 													
						{};

EnumDecl :		ENUM ID {
							Variable* var = symbolTable.getVar($2->name);
							Variable* var_as_class = symbolTable.getVar("enum "+$2->name);
							if(var != nullptr || symbolTable.isThereEnumContains($2->name) || var_as_class != nullptr){
							
								errorDef(yylineno, $2->name);
								
								delete $2;
								exit(0);
							}
							
							
							curEnumClass = new Enum_class("enum " + $2->name);
							delete $2;
							
						} LBRACE EnumeratorList RBRACE SC 	
							
						{symbolTable.insertVar(curEnumClass);};

RetType :		Type 														
						{$$ = $1;}
				| VOID 																
						{$$ = new Node(VOID_t);};

Formals :		/*epsilon*/ 												
						{}
				| FormalsList 														
						{};

FormalsList :	FormalDecl 													
						{}
				| FormalDecl COMMA FormalsList 									
						{};

FormalDecl :	Type ID 													
						{
							
							Variable* var = symbolTable.getVar($2->name);
							Variable* var_as_class = symbolTable.getVar("enum "+$2->name);
							if(var != nullptr || symbolTable.isThereEnumContains($2->name) || var_as_class != nullptr){
							
								errorDef(yylineno, $2->name);
								
								delete $2;
								exit(0);
							}
							Variable* allocated_param = new Variable($1->type,$2->name);
							allocated_param->reg = a.RegAlloc();
							curFunc->addParam(allocated_param);
							$2->type = $1->type;
						
						}
				| EnumType ID 														
						{
						
							Variable* var = symbolTable.getVar($2->name);
							Variable* var_as_class = symbolTable.getVar("enum "+$2->name);
							if(var != nullptr || symbolTable.isThereEnumContains($2->name) || var_as_class != nullptr){
							
								errorDef(yylineno, $2->name);
								
								delete $2;
								exit(0);
							}
							auto tmp = (Enum_class*)$1;
							if(!symbolTable.CheckIfEnumInGlobalScope(tmp)){
							errorUndef(yylineno,$1->name);
							delete $1;
							exit(0);
							}
							curFunc->addParam(new Enum_var(ENUM_t, (Enum_class*) $1, $2->name,0,""));
							$2->type = $1->type;
						
						};


EnumeratorList :	Enumerator 											
						{
						
						}
				| EnumeratorList COMMA Enumerator 									
						{};

Enumerator :		ID 															
						{
						
							Variable* var = symbolTable.getVar($1->name);
						
							Variable* var_as_class = symbolTable.getVar("enum "+$1->name);


							
							if(var != nullptr || symbolTable.isThereEnumContains($1->name) || var_as_class != nullptr || curEnumClass->contains($1->name) || "enum " + $1->name == curEnumClass->name){
					
								errorDef(yylineno, $1->name);
								delete $1;
								exit(0);
							}
							
							
						curEnumClass->enum_vals.push_back($1->name);
						  delete $1;
						 
						};

Statements :	Statement 													
						{
							$$->nextlist = $1->nextlist;
						}
				| Statements  Statement 												
						{
							$$->nextlist = $2->nextlist;
						};

Statement :		LBRACE OPENORMAL Statements RBRACE CLOSE
						{
							$$->nextlist = $3->nextlist;
						}
				| Type ID SC 														

						{	
						
							Variable* var = symbolTable.getVar($2->name);
							Variable* var_as_class = symbolTable.getVar("enum "+$2->name);
							if(var != nullptr || symbolTable.isThereEnumContains($2->name) || var_as_class != nullptr){
							
								errorDef(yylineno, $2->name);
								delete $1;
								delete $2;
								exit(0);
							}
							var = new Variable($1->type,$2->name);
							int size = symbolTable.scopes_table.size();
							var->reg = a.Var_Alloc(var->type);
							symbolTable.insertVar(var);
							

							delete $1;
							delete $2;
						}
				| EnumType ID  SC 													
						{
						
						Variable* var = symbolTable.getVar($2->name);
							Variable* var_as_class = symbolTable.getVar("enum "+$2->name);
							if(var != nullptr || symbolTable.isThereEnumContains($2->name) || var_as_class != nullptr){
							
								errorDef(yylineno, $2->name);
								delete $1;
								delete $2;
								exit(0);
							}
							//check here abut value
							var = new Enum_var(ENUM_t, (Enum_class*) $1  , $2->name,0,"");
							
							symbolTable.insertVar(var);
							var->reg = a.Var_Alloc();

							delete $2;
						
						
						}
				| EnumDecl 															
		
						{}
				| Type ID ASSIGN Exp SC 											
						{
							
							
							Variable* var = symbolTable.getVar($2->name);
							Variable* var_as_class = symbolTable.getVar("enum "+$2->name);
							if(var != nullptr || symbolTable.isThereEnumContains($2->name) || var_as_class != nullptr){
							
								errorDef(yylineno, $2->name);
								
								exit(0);
							}
							
							if($1->type != $4->type && (!($1->type == INT_t  && $4->type == BYTE_t  )) && $4->type != FUNCTION_t )
							{
							
							
								errorMismatch(yylineno);
								
								exit(0);
							}
							
							//check if exp is call func
							if ($4->type == FUNCTION_t){
								
								Function* f = (Function*)$4;
								if($1->type != f->returnType && (!($1->type == INT_t  && f->returnType == BYTE_t  )) ){
									errorMismatch(yylineno);
									exit(0);
									}
								
							}
							
							
							var = new Variable($1->type,$2->name);
							var->falselist = $4->falselist;
							var->truelist = $4->truelist;
							var->nextlist = $4->nextlist;
							var->reg = a.Var_Alloc(var->type);
							if ($4->type != FUNCTION_t)
								a.Var_Alloc_And_Assign(var->reg,$1->type,$4);
							else{
								a.Var_Alloc_And_Assign(var->reg,$1->type,$4,&args);
							}
							symbolTable.insertVar(var);
							

							
							
						}
				| EnumType ID ASSIGN Exp { 
							
							Variable* var = symbolTable.getVar($2->name);
							Variable* var_as_class = symbolTable.getVar("enum "+$2->name);
							if(var != nullptr || symbolTable.isThereEnumContains($2->name) || var_as_class != nullptr){
							
								errorDef(yylineno, $2->name);
								delete $1;
								delete $2;
								delete $4;
								exit(0);
							}
								
								auto tmp = (Enum_class*)$1;
								auto var_to_assign =symbolTable.getVar($4->name);
								if ((! tmp->contains($4->name)) && !(tmp->contains(var_to_assign->value))   ){
								
									cout << "tmp->name = " << tmp->name << "  , $4->name = " << $4->name  << "  v_t_a->value = "<< var_to_assign->value << endl;
									errorUndefEnumValue(yylineno,$2->name);
									delete $2;
											
									exit(0);		
								
								}
								//TODO: check if exp is function
								$2->reg  = a.Var_Alloc();
								a.Var_Alloc_And_Assign($2->reg ,INT_t,$4,nullptr);
								
							}
				SC{
								Enum_var* new_var = new Enum_var(ENUM_t, (Enum_class*) $1   ,$2->name,0,$4->value);
										symbolTable.insertVar(new_var);
										new_var->falselist = $4->falselist;
										new_var->truelist = $4->truelist;
										new_var->nextlist = $4->nextlist;
										
										delete $2;
										
				}	
				| ID ASSIGN Exp SC 													
						{
						
							Variable* var = symbolTable.getVar($1->name);
							if(var == nullptr || var->type == FUNCTION_t ){
								
								errorUndef(yylineno, $2->name);
								delete $1;
								
								exit(0);
							}
							
							if( var->type !=ENUM_t && $3->type != FUNCTION_t && (var->type != $3->type) && (var->type != INT_t && $3->type != BYTE_t)){
						
								errorMismatch(yylineno);
								delete $1;
								
								exit(0);
							}
							//check if exp is call func
							if ($3->type == FUNCTION_t){
								
								Function* f = (Function*)symbolTable.getVar($3->name);
								if(var->type != f->returnType && (!(var->type == INT_t  && f->returnType == BYTE_t  )) ){
								errorMismatch(yylineno);
								exit(0);
								}
								
							}
							if(var->type == ENUM_t && ($3->type == ENUM_t || $3->type == INT_t || $3->type == BYTE_t || $3->type == BOOL_t|| $3->type == STRING_t || $3->type == VOID_t)){
								auto tmp = (Enum_var*)var;
								auto tmp_class = (Enum_class*)symbolTable.getVar(tmp->enum_type);
								auto var_to_assign =symbolTable.getVar($3->name);
								if (tmp_class == nullptr || (!tmp_class->contains($3->name)   &&  !(tmp_class->contains(var_to_assign->value))  )){
									errorUndefEnumValue(yylineno,var->name);
									exit(0);
								}
							}
								var->value = $3->value;
								var->falselist = $3->falselist;
								var->nextlist = $3->nextlist;
								var->truelist = $3->truelist;
								//CodeBuffer::instance().emit("name is " + var->name + "value is " + var->value + "reg is " + var->reg);
							//the name of the func says alloc, but don't worry it doesn't alloc anything
							if ($3->type == FUNCTION_t)
								a.Var_Alloc_And_Assign(var->reg,var->type,$3,&args);
							else if($3->type == ENUM_t){
							
								var->reg = a.Var_Alloc();
								a.Var_Alloc_And_Assign(var->reg ,INT_t,$3,nullptr);
								
							}else{
								a.Var_Alloc_And_Assign(var->reg,var->type,$3);
								}
							
							
							

							delete $1;
							
						}
				| Call SC 															
						{
						
						}
				| RETURN SC 														
						{
							auto& scope = symbolTable.scopes_table[symbolTable.scopes_table.size()-1 < 0 ? 0 : symbolTable.scopes_table.size()-1 ];
							assert(scope.curFunc != nullptr);//grammar makes sure
							auto f = scope.curFunc;
							if(f->returnType != VOID_t){
								errorMismatch(yylineno);
								exit(0);
							}
							
							a.genReturn(scope.curFunc);
							return_flag = false;
						}
				| RETURN Exp SC 													
						{
							auto& scope = symbolTable.scopes_table[symbolTable.scopes_table.size()-1 < 0 ? 0 : symbolTable.scopes_table.size()-1];
							assert(scope.curFunc != nullptr);//grammar makes sure
							auto f = scope.curFunc;
							if($2->type != FUNCTION_t && (f->returnType != $2->type || $2->type == VOID_t) && !(f->returnType == INT_t && $2->type == BYTE_t) ){
								errorMismatch(yylineno);
								delete $2;
								exit(0);
							}
							
							
							
							//check if exp is call func
							if ($2->type == FUNCTION_t){
								
								Function* exp_f = (Function*)$2;
								if(f->returnType != exp_f->returnType && (!(f->returnType == INT_t  && exp_f->returnType == BYTE_t  )) ){
									errorMismatch(yylineno);
									exit(0);
								}
								
							}
							
							
							a.genReturn(f , $2);
							return_flag = false;
							
						}
						
					
				| IF LPAREN checkBoolExp MAKE_IF_BR M RPAREN OPENORMAL Statement CLOSE  									
						{
						
						pair<int,BranchLabelIndex> p = pair<int,BranchLabelIndex>(last_br_emit.top(),FIRST);
						pair<int,BranchLabelIndex> p2 = pair<int,BranchLabelIndex>(last_br_emit.top(),SECOND);
						$3->truelist =  CodeBuffer::instance().merge($3->truelist , CodeBuffer::instance().makelist(p));
						$3->falselist =  CodeBuffer::instance().merge($3->falselist , CodeBuffer::instance().makelist(p2));
						
						CodeBuffer::instance().bpatch($3->truelist, $5->reg);
						
						//-------
						$$->nextlist = CodeBuffer::instance().merge($8->nextlist , $3->falselist);
						
						int i = CodeBuffer::instance().emit("	br label @");
						string DoneL =  CodeBuffer::instance().genLabel();
						CodeBuffer::instance().bpatch($$->nextlist, DoneL);
						
						
						pair<int,BranchLabelIndex> p3 = pair<int,BranchLabelIndex>(i,FIRST);
						CodeBuffer::instance().bpatch(CodeBuffer::instance().makelist(p3),DoneL);
						
						last_br_emit.pop();
						}
				
				
				| IF LPAREN checkBoolExp MAKE_IF_BR M RPAREN OPENORMAL Statement CLOSE ELSE MELSE M OPENORMAL Statement CLOSE
						{
						
						
						pair<int,BranchLabelIndex> p = pair<int,BranchLabelIndex>(last_br_emit.top(),FIRST);
						pair<int,BranchLabelIndex> p2 = pair<int,BranchLabelIndex>(last_br_emit.top(),SECOND);
						$3->truelist =  CodeBuffer::instance().merge($3->truelist , CodeBuffer::instance().makelist(p));
						$3->falselist =  CodeBuffer::instance().merge($3->falselist , CodeBuffer::instance().makelist(p2));
						
						
						CodeBuffer::instance().bpatch($3->truelist, $5->reg);
						CodeBuffer::instance().bpatch($3->falselist, $12->reg);
						
						//--------
						
						$$->nextlist = CodeBuffer::instance().merge($8->nextlist , $14->nextlist);//after done from true body, and false body
						$$->nextlist = CodeBuffer::instance().merge($$->nextlist , CodeBuffer::instance().makelist(last_MELSE.top()));//add to it the nextlist of MELSE
						
						
						int i = CodeBuffer::instance().emit("	br label @");//doneLabel after the else body
						string DoneL =  CodeBuffer::instance().genLabel();
						
						
						CodeBuffer::instance().bpatch($$->nextlist, DoneL);
						pair<int,BranchLabelIndex> p3 = pair<int,BranchLabelIndex>(i,FIRST);
						
						auto doneList = CodeBuffer::instance().makelist(p3);
						//doneList = CodeBuffer::instance().merge(doneList, $11->nextlist);
						
						CodeBuffer::instance().bpatch(doneList ,DoneL);
						
						last_br_emit.pop();
						}
				
			
				| MAKE_WHILE WHILE LPAREN M checkBoolExp  MAKE_IF_BR  M OPENLOOP RPAREN  Statement 									
				{
					
					//TODO ask salih for this
					$$ = new Node(UNDEFYET_t);
					pair<int,BranchLabelIndex> p_while = pair<int,BranchLabelIndex>(last_while_emit.top(),FIRST);
					
					
					last_while_emit.pop();
					CodeBuffer::instance().bpatch( CodeBuffer::instance().makelist(p_while), $4->reg);
					
				
					
					pair<int,BranchLabelIndex> p = pair<int,BranchLabelIndex>(last_br_emit.top(),FIRST);
					
					pair<int,BranchLabelIndex> p2 = pair<int,BranchLabelIndex>(last_br_emit.top(),SECOND);
					
					$5->truelist =  CodeBuffer::instance().merge($5->truelist , CodeBuffer::instance().makelist(p));
					
					
					$5->falselist =  CodeBuffer::instance().merge($5->falselist , CodeBuffer::instance().makelist(p2));
					
				//	cout << "here" << endl;
				//	cout << "here " << $$->type<< endl;
				//	cout << "here " << $$->nextlist.size()<< endl;
					$$->nextlist = CodeBuffer::instance().merge($$->nextlist, $5->falselist);
					$$->nextlist = CodeBuffer::instance().merge($$->nextlist, Break_labels.top());
				//	cout << "here " << $$->type<< endl;
					
					
					$$->nextlist = CodeBuffer::instance().merge($$->nextlist, $10->nextlist);
					
					CodeBuffer::instance().bpatch($5->truelist, $7->reg);
					
					

					
					
					int i = CodeBuffer::instance().emit("	br label @");
					pair<int,BranchLabelIndex> p3 = pair<int,BranchLabelIndex>(i,FIRST);
					string DoneL = CodeBuffer::instance().genLabel();
					CodeBuffer::instance().bpatch(CodeBuffer::instance().makelist(p3),$4->reg);
					CodeBuffer::instance().bpatch(Cont_labels.top(), $4->reg);
					
					CodeBuffer::instance().bpatch($$->nextlist, DoneL);
					
					
					
                    symbolTable.closeScope();
					last_br_emit.pop();
					Break_labels.pop();
					Cont_labels.pop();
				}
						 
						
						
				| BREAK SC 															
						{
							auto& scope = symbolTable.scopes_table[symbolTable.scopes_table.size()-1 < 0 ? 0 : symbolTable.scopes_table.size()-1];
							if(!scope.isLoop){
								errorUnexpectedBreak(yylineno);
								exit(0);
							}
							
							//TODO: add nextlist code for it?
							int i = CodeBuffer::instance().emit("	br label @");
							a.RegAlloc();//something about labels ,, llvm sucks
							pair<int,BranchLabelIndex> p = pair<int,BranchLabelIndex> ( i, FIRST);
							Break_labels.top().push_back(p);
				
							
						}
				| CONTINUE SC 														
						{
							auto& scope = symbolTable.scopes_table[symbolTable.scopes_table.size()-1 < 0 ? 0 : symbolTable.scopes_table.size()-1];
							if(!scope.isLoop){
								errorUnexpectedContinue(yylineno);
								exit(0);
							}
							//TODO: add nextlist code for it?
							int i = CodeBuffer::instance().emit("	br label @");
							a.RegAlloc();//something about labels ,, llvm sucks
							pair<int,BranchLabelIndex> p = pair<int,BranchLabelIndex> ( i, FIRST);
							Cont_labels.top().push_back(p);
						};
checkBoolExp :     Exp {
				
						if($1->type != BOOL_t)
						{
							errorMismatch(yylineno);
							exit(0);
						}
						
						last_bool_exp = $1;
						//$$ = $1;

					}
Call :			ID LPAREN {ParamListStack.push(vector<Node*>()); } ExpList RPAREN 										
						{
						
							Function* callee = (Function*)symbolTable.getVar($1->name);
							auto& vec = ParamListStack.top();



							if (callee == nullptr || callee->type != FUNCTION_t){
								
								errorUndefFunc(yylineno, $1->name);
								ParamListStack.pop();
								delete $1;
								exit(0);
							}
							delete $1;
							
							callee->ValidateParameters(vec,symbolTable);
							
							args = vec;
							
							
							callee->reg = a.genCall(callee->name,callee->returnType,callee->paramTypes,args);
							$$ = callee;
							
							ParamListStack.pop();
							
						}

				| ID LPAREN RPAREN 													
						{	
							Function* callee = (Function*)symbolTable.getVar($1->name);
							auto vec = vector<Node*>();
							
							
							if (callee == nullptr || callee->type != FUNCTION_t){
								
								errorUndefFunc(yylineno, $1->name);
								delete $1;
								exit(0);
							}

							delete $1;
							
							
							$$ = callee;
							args=vec;
							
							callee->ValidateParameters(vec,symbolTable);
							callee->reg = a.genCall(callee->name,callee->returnType,callee->paramTypes,args);
							

						};

ExpList :		Exp 														
						{ParamListStack.top().push_back($1);}
				| Exp COMMA ExpList 												
						{ParamListStack.top().push_back($1);};

Type :			INT 															
						{
						
					
						$$ = new Node(INT_t);}
				| BYTE 																
						{$$ = new Node(BYTE_t);}
				| BOOL 																
						{
						
						$$ = new Node(BOOL_t);};

EnumType :		ENUM ID 													
						{Node* var = symbolTable.getVar("enum " + $2->name);
							if (var == nullptr){
								errorUndefEnum(yylineno, $2->name);
								delete $2;
								exit(0);
							}
							delete $2;
							$$ = var;
						};
						

Exp :			LPAREN Exp RPAREN 											
						{$$ = $2;}

				| Exp ADDOPS Exp 													
						{ if (($1->type != INT_t && $1->type !=BYTE_t) || ($3->type != INT_t && $3->type != BYTE_t)){
							errorMismatch(yylineno);
							delete $1;
							delete $3;
							exit(0);
						}
						if ($1->type == BYTE_t && $3->type == BYTE_t){
							
							$$ = new Node(BYTE_t);
							$$->is_Var = true;
							$$->reg = a.genAddOp($1,$3,$2->value,BYTE_t);
						}
						else{ 
							
							$$= new Node(INT_t);
							//its valued is save in an allocated place , so we need that.
							$$->is_Var = true;
							$$->reg = a.genAddOp($1,$3,$2->value);
							}

						}
				| Exp MULTOPS Exp 													
						{ if (($1->type != INT_t && $1->type !=BYTE_t) || ($3->type != INT_t && $3->type != BYTE_t)){
							errorMismatch(yylineno);
							delete $1;
							delete $3;
							exit(0);
						}
						if ($1->type == BYTE_t && $3->type == BYTE_t){
							
							$$ = new Node(BYTE_t);
							$$->is_Var = true;
							$$->reg = a.genAddOp($1,$3,$2->value,BYTE_t);
						}
						else{ 
							$$= new Node(INT_t);
							//its valued is save in an allocated place , so we need that.
							$$->is_Var = true;
							$$->reg = a.genAddOp($1,$3,$2->value);
							}

						}

				| ID 																
					{
					Variable* var = symbolTable.getVar($1->name);
							if(  var == nullptr ){
							
								if (!symbolTable.isThereEnumContains($1->name)){
								
								errorUndef(yylineno, $1->name);
								delete $1;
								exit(0);
								}
							}
							
						if (symbolTable.isThereEnumContains($1->name) && var == nullptr){

							auto tmp = symbolTable.FindEnumContains($1->name);//we know this isn't nullptr for sure
							$$ = new Enum_var(ENUM_t,  tmp,  $1->name,0,$1->name);
							
							//TODO: add emit code for enum case, if needed(im guessing yes needed)
						}
						else{
							$$ = var;
						}
						
						
					}

				| Call 																
					{
						
						
						Function* callee = (Function*)$1;
						
						
						
						//a.Var_Alloc_And_Assign($$->reg,callee->returnType,callee,&args);
						
						
						//a.genCall(callee->name,callee->returnType,callee->paramTypes,args,true);
						//$$ = new Node( ((Function*)$1)->returnType , "" , callee->value , a.RegAlloc());
						
						
						
						
						
					}

				| NUM 																
						{ 
						//no need here for Var_Alloc
						$$ = new Node(INT_t , $1->name , $1->value);
						
							delete $1;
						}

				| NUM B 														
					{	if( !( stoi($1->value) >= 0 && (stoi($1->value) <= 255))){
										
											errorByteTooLarge(yylineno, $1->value);
											delete $1;
											exit(0);
										}
						$$ = new Node(BYTE_t,$1->name,$1->value, $1->value);
						delete $1;

					}

				| STRING 															
						{
							$$ = new Node(STRING_t,$1->name,$1->name); 
							//might not need this anyways but TODO: no need to do emit code? emitGlobal? what the fuck?
						}

				| TRUE 																
						{
						
							$$ = new Node(BOOL_t,"","true", a.RegAlloc());
							//$$->is_Var = true;
							a.genBool($$);
						
						}

				| FALSE 															
						{
							$$ = new Node(BOOL_t,"","false", a.RegAlloc());
							//$$->is_Var = true;
							a.genBool($$);
						}
						
				| NOT checkBoolExp 															
						{
							if($2->type != BOOL_t){
									errorMismatch(yylineno);
									delete $2;
									exit(0);
							}
						
							string my_reg = a.RegAlloc();
							$$ = new Node(BOOL_t , "" , "",my_reg);
							$$->is_Var = $2->is_Var;//check this $2->is_Var;
							
							if (!($2->is_Var)){
								$$->value = $2->value == "true" ? "false" : "true";
								
							}else{
								$$->truelist = $2->falselist;
								$$->falselist = $2->truelist;
							}
							
							//TODO: fix this
							a.genBool($$,$2->reg);
						}


				| checkBoolExp AND checkBoolExp ANDGEN M MAKE_IF_BR M												
						{
						
							if($1->type != BOOL_t || $3->type != BOOL_t){
									errorMismatch(yylineno);
									delete $1;
									delete $3;
									exit(0);
							}
							
							
							pair<int,BranchLabelIndex> p = pair<int,BranchLabelIndex>(last_br_emit.top(),FIRST);
							pair<int,BranchLabelIndex> p2 = pair<int,BranchLabelIndex>(last_br_emit.top(),SECOND);
							auto l1 =  CodeBuffer::instance().makelist(p);
							auto l2 =  CodeBuffer::instance().makelist(p2);
						
								
							CodeBuffer::instance().bpatch($1->truelist,$5->reg);
							CodeBuffer::instance().bpatch($4->nextlist,$5->reg);
							CodeBuffer::instance().bpatch(l1,$7->reg);
							
							
							$$ = new Node(BOOL_t , "" ,"",a.RegAlloc());
							$$->is_Var = $1->is_Var;
							
							if (!($1->is_Var)){
								$$->value = $1->value;
								
							}
							
							//TODO: fix this
							a.genBool($$,$1->reg);
							
							
							$$->falselist = CodeBuffer::instance().merge($1->falselist,$3->falselist);
							$$->falselist = CodeBuffer::instance().merge($$->falselist,l2);
						
							last_br_emit.pop();
							

						}

				| checkBoolExp OR checkBoolExp ANDGEN M MAKE_IF_BR M												
						{
						
							if($1->type != BOOL_t || $3->type != BOOL_t){
									errorMismatch(yylineno);
									delete $1;
									delete $3;
									exit(0);
							}
							
							
							pair<int,BranchLabelIndex> p = pair<int,BranchLabelIndex>(last_br_emit.top(),FIRST);
							pair<int,BranchLabelIndex> p2 = pair<int,BranchLabelIndex>(last_br_emit.top(),SECOND);
							auto l1 =  CodeBuffer::instance().makelist(p);
							auto l2 =  CodeBuffer::instance().makelist(p2);
						
								
							CodeBuffer::instance().bpatch($1->falselist,$5->reg);
							CodeBuffer::instance().bpatch($4->nextlist,$5->reg);
							CodeBuffer::instance().bpatch(l2,$7->reg);
							
							
							$$ = new Node(BOOL_t , "" ,"",a.RegAlloc());
							$$->is_Var = $1->is_Var;
							
							if (!($1->is_Var)){
								$$->value = $1->value;
								
							}
							
							//TODO: fix this
							a.genBool($$,$1->reg);
							
							
							$$->truelist = CodeBuffer::instance().merge($1->truelist,$3->truelist);
							$$->truelist = CodeBuffer::instance().merge($$->truelist,l1);
						
							last_br_emit.pop();
							

						}

				| Exp RELATIONOP Exp 												
						{
							
							
							if( ($1->type != INT_t && $1->type != BYTE_t) || ($3->type != INT_t && $3->type != BYTE_t)){
									errorMismatch(yylineno);
									delete $1;
									delete $3;
									exit(0);
							}
							
							$$ = new Node(BOOL_t);
							
								
								
							$$->reg = a.genBoolFromRelOp($1,$3,$2->value, &($$->value));
						}

				| Exp EQUALOP Exp 													
						{
							if(($1->type != INT_t && $1->type != BYTE_t) || ($3->type != INT_t && $3->type != BYTE_t)){
									errorMismatch(yylineno);
									delete $1;
									delete $3;
									exit(0);
							}
							$$ = new Node(BOOL_t);
							$$->reg = a.genBoolFromRelOp($1,$3,$2->value, &($$->value));
						}

				| LPAREN Type RPAREN Exp 
				
						{	
						if ( $2->type != INT_t){
								delete $2;
								errorMismatch(yylineno);
								exit(0);
								}
						
							if($4->type != ENUM_t && !(symbolTable.isThereEnumContains($4->name))){
								delete $2;
								
								errorMismatch(yylineno);
								exit(0);
							}
							Node* enum_var = symbolTable.getVar($4->name);
							if (enum_var == nullptr && !(symbolTable.isThereEnumContains($4->name))){
								delete $2;
								
								errorUndef(yylineno,$4->name);
								exit(0);
							}
							
							auto enum_var_casted = enum_var==nullptr ? nullptr : (Enum_var*)enum_var; 
							string enum_var_name = enum_var==nullptr ? "" : enum_var_casted->name;
							int enum_var_offset = enum_var==nullptr ? 0 : enum_var_casted->offset; 
							string enum_var_value = enum_var==nullptr ? "" : enum_var_casted->value; 
							Variable* new_int = new Variable(INT_t,enum_var_name,enum_var_offset,enum_var_value);
							delete $2;
							$$ = new_int;
							
							
							//Enum_class* enum_class = symbolTable.FindEnumContains(enum_var->value);
							$$->reg = a.Var_Alloc();
							a.Var_Alloc_And_Assign($$->reg ,INT_t,enum_var,nullptr);
							
							
						};
						
						
OPENORMAL:					{symbolTable.openScope(NORMAL);};
OPENLOOP:					{symbolTable.openScope(LOOP);};
CLOSE:						{symbolTable.closeScope();};

MAKE_WHILE:				{
							last_while_emit.push( CodeBuffer::instance().emit("	br label @") );
							auto break_vec = vector< pair<int,BranchLabelIndex>>();
							Break_labels.push(break_vec);
							auto cont_vec = vector< pair<int,BranchLabelIndex>>();
							Cont_labels.push(cont_vec);
						}	
MAKE_IF_BR:				{
							last_br_emit.push( a.genIF(last_bool_exp) );
						}
			
M:      				{
							$$ = new Node( UNDEFYET_t,"" ,"",   CodeBuffer::instance().genLabel());//saves the label in reg
						}
MELSE:					{
						//this one makes sure that if we are in the if body (the if cond is true) and there is an else body, we use this to skip the else body
						
						
							$$ = new Node(UNDEFYET_t, ""); 
							
							int i = CodeBuffer::instance().emit("	br label @");
							pair<int,BranchLabelIndex> p = pair<int,BranchLabelIndex> ( i, FIRST);
							auto l = CodeBuffer::instance().makelist(p);
							$$->nextlist = l;
							
							last_MELSE.push(p);
						}
ANDGEN:					{
							$$ = new Node(UNDEFYET_t, ""); 
							
							int i = CodeBuffer::instance().emit("	br label @");
							pair<int,BranchLabelIndex> p = pair<int,BranchLabelIndex> ( i, FIRST);
							auto l = CodeBuffer::instance().makelist(p);
							$$->nextlist = l;
							
							
						}
%%



int main()
{

	symbolTable.openScope(GLOBAL);
	curFunc = new Function("print", VOID_t);
	Variable* dummy = new Variable(STRING_t);
	curFunc->addParam(dummy);
	symbolTable.insertFunc(curFunc);
	symbolTable.scopes_table.pop_back();
	symbolTable.offset_stack.pop();
	
	curFunc = new Function("printi", VOID_t);
	dummy = new Variable(INT_t,"");
	curFunc->addParam(dummy);
	symbolTable.insertFunc(curFunc);
	symbolTable.scopes_table.pop_back();
	symbolTable.offset_stack.pop();
	a.Gen_Printers();
	
	yyparse();
	
	
	
	/*checking if main exsists*/
	Function* main_func = (Function*)symbolTable.getVar("main");
	if (main_func == nullptr || main_func->type != FUNCTION_t || main_func->paramTypes.size()!= 0 || main_func->returnType != VOID_t){
		errorMainMissing();
		return 0;
	}
	
	symbolTable.closeScope();
	CodeBuffer::instance().printCodeBuffer();

	

    return 0;
}

void yyerror(char const* error){
	errorSyn(yylineno);
	exit(0);
}





