%{
	#include <stdio.h>
	#include <iostream>
	#include "LLVM_generator.hpp"
	#include "hw3_output.hpp"
	
	

	
	int yylex();
	void yyerror(const char*);
	extern int yylineno;
	
	using namespace std;
	using namespace output;
	
	Symbol_Table symbolTable = Symbol_Table();
	Function* curFunc;
	Enum_class* curEnumClass;
	stack<vector<Node*>> ParamListStack = stack<vector<Node*>>();
	Genreator a = Genreator();
	vector<Node*> args = vector<Node*>(); // this is for call
	stack<bool> return_flag;
	bool return_flag_value;
	
	
		//these are for if, and loops and shit like that
	stack<int> last_br_emit;
	stack<int> last_while_emit;
	stack< pair<int,BranchLabelIndex> > last_MELSE = stack< pair<int,BranchLabelIndex> >();//this is not technecacly needed but this parser is an idiot, (or we are, meh :) )
	stack< vector< pair<int,BranchLabelIndex>> > Break_labels = stack<vector< pair<int,BranchLabelIndex> >>();
	stack< vector< pair<int,BranchLabelIndex>> > Cont_labels = stack<vector< pair<int,BranchLabelIndex> >>();
	Node* last_bool_exp = nullptr;
	

%}




%token  VOID INT BYTE B BOOL ENUM TRUE FALSE RETURN ELSE WHILE BREAK CONTINUE SC COMMA LBRACE RBRACE ID NUM STRING
%right ASSIGN
%left OR
%left AND
%left EQUALOP
%left RELATIONOP
%left ADDOPS
%left MULTOPS
%right LPAREN RPAREN
%right IF ELSE
%right NOT


%%

Program : 		Enums Funcs 										
						{};


Funcs :			/*epsilon*/ 													
						{}
				| FuncDecl Funcs 													
						{};



FuncDecl :		RetType ID  {
							return_flag = stack<bool>();
							return_flag.push(true); 
							
							Variable* var = symbolTable.getVar($2->name);
							Variable* var_as_class = symbolTable.getVar("enum "+$2->name);
							if(var != nullptr || symbolTable.isThereEnumContains($2->name) || var_as_class != nullptr){
							
								errorDef(yylineno, $2->name);
								delete $1;
								delete $2;
								exit(0);
							}
						
							curFunc = new Function($2->name,$1->type);
							$2->type = FUNCTION_t;
							
						} LPAREN Formals RPAREN LBRACE 
						{
					
						symbolTable.insertFunc(curFunc);
						
			
						
					
						vector<string> string_prms = TypeToLvmTypes(curFunc->paramTypes);
						string return_as_string = TokenTypeToLlvmType(curFunc->returnType);
						
						a.funcDecGen($2->name ,return_as_string , string_prms, curFunc->params);
						
						
						}
						Statements {
							
							if (return_flag.top()){
								a.genReturn(curFunc);
							}
							
							
							} RBRACE 
						{	
							
							CodeBuffer::instance().emit("}");
							a.clear_regs();
							symbolTable.closeScope();
							delete $1;
							delete $2;
							
							
							
						
						
						}
						;
//TODO: find out how the fuck to make Enum in llvm
Enums :			/*epsilon*/ 															
						{}
				| EnumDecl Enums 													
						{};

EnumDecl :		ENUM ID {
							Variable* var = symbolTable.getVar($2->name);
							Variable* var_as_class = symbolTable.getVar("enum "+$2->name);
							if(var != nullptr || symbolTable.isThereEnumContains($2->name) || var_as_class != nullptr){
							
								errorDef(yylineno, $2->name);
								
								delete $2;
								exit(0);
							}
							
							
							curEnumClass = new Enum_class("enum " + $2->name);
							delete $2;
							
						} LBRACE EnumeratorList RBRACE SC 	
							
						{symbolTable.insertVar(curEnumClass);};

RetType :		Type 														
						{$$ = $1;}
				| VOID 																
						{$$ = new Node(VOID_t);};

Formals :		/*epsilon*/ 												
						{}
				| FormalsList 														
						{};

FormalsList :	FormalDecl 													
						{}
				| FormalDecl COMMA FormalsList 									
						{};

FormalDecl :	Type ID 													
						{
							
							Variable* var = symbolTable.getVar($2->name);
							Variable* var_as_class = symbolTable.getVar("enum "+$2->name);
							if(var != nullptr || symbolTable.isThereEnumContains($2->name) || var_as_class != nullptr){
							
								errorDef(yylineno, $2->name);
								
								delete $2;
								exit(0);
							}
							Variable* allocated_param = new Variable($1->type,$2->name);
							allocated_param->reg = a.RegAlloc();
							curFunc->addParam(allocated_param);
							$2->type = $1->type;
						
						}
				| EnumType ID 														
						{
						
							Variable* var = symbolTable.getVar($2->name);
							Variable* var_as_class = symbolTable.getVar("enum "+$2->name);
							if(var != nullptr || symbolTable.isThereEnumContains($2->name) || var_as_class != nullptr){
							
								errorDef(yylineno, $2->name);
								
								delete $2;
								exit(0);
							}
							auto tmp = (Enum_class*)$1;
							if(!symbolTable.CheckIfEnumInGlobalScope(tmp)){
							errorUndef(yylineno,$1->name);
							delete $1;
							exit(0);
							}
							curFunc->addParam(new Enum_var(ENUM_t, (Enum_class*) $1, $2->name,0,""));
							$2->type = $1->type;
						
						};


EnumeratorList :	Enumerator 											
						{
						
						}
				| EnumeratorList COMMA Enumerator 									
						{};

Enumerator :		ID 															
						{
						
							Variable* var = symbolTable.getVar($1->name);
						
							Variable* var_as_class = symbolTable.getVar("enum "+$1->name);


							
							if(var != nullptr || symbolTable.isThereEnumContains($1->name) || var_as_class != nullptr || curEnumClass->contains($1->name) || "enum " + $1->name == curEnumClass->name){
					
								errorDef(yylineno, $1->name);
								delete $1;
								exit(0);
							}
							
							
						curEnumClass->enum_vals.push_back($1->name);
						  delete $1;
						 
						};

Statements :	Statement 													
						{
							
							$$->nextlist = $1->nextlist;
							//cout << "4" << endl;
						}
				| Statements  Statement 												
						{	
							//cout << "1" << endl;
							$$->nextlist = $2->nextlist;
							//cout << "2" << endl;
							//cout << "2222222222222222222222222222222222222222222" << endl;
						};

Statement :		LBRACE OPENORMAL Statements RBRACE CLOSE
						{
							$$->nextlist = $3->nextlist;
						}
				| Type ID SC 														

						{	
						
							Variable* var = symbolTable.getVar($2->name);
							Variable* var_as_class = symbolTable.getVar("enum "+$2->name);
							if(var != nullptr || symbolTable.isThereEnumContains($2->name) || var_as_class != nullptr){
							
								errorDef(yylineno, $2->name);
								delete $1;
								delete $2;
								exit(0);
							}
							var = new Variable($1->type,$2->name);
							int size = symbolTable.scopes_table.size();
							var->reg = a.Var_Alloc(var->type);
							symbolTable.insertVar(var);
							

							delete $1;
							delete $2;
							
							//ask saleh
							$$ = new Node(UNDEFYET_t);
						}
				| EnumType ID  SC 													
						{
						
						Variable* var = symbolTable.getVar($2->name);
							Variable* var_as_class = symbolTable.getVar("enum "+$2->name);
							if(var != nullptr || symbolTable.isThereEnumContains($2->name) || var_as_class != nullptr){
							
								errorDef(yylineno, $2->name);
								delete $1;
								delete $2;
								exit(0);
							}
							//check here abut value
							var = new Enum_var(ENUM_t, (Enum_class*) $1  , $2->name,0,"");
							
							symbolTable.insertVar(var);
							var->reg = a.Var_Alloc();

							delete $2;
						//ask saleh
							$$ = new Node(UNDEFYET_t);
						
						}
				| EnumDecl 															
		
						{}
				| Type ID ASSIGN Exp SC 											
						{
							
							
							Variable* var = symbolTable.getVar($2->name);
							Variable* var_as_class = symbolTable.getVar("enum "+$2->name);
							if(var != nullptr || symbolTable.isThereEnumContains($2->name) || var_as_class != nullptr){
							
								errorDef(yylineno, $2->name);
								
								exit(0);
							}
							
							if($1->type != $4->type && (!($1->type == INT_t  && $4->type == BYTE_t  )) && $4->type != FUNCTION_t )
							{
							
							
								errorMismatch(yylineno);
								
								exit(0);
							}
							
							//check if exp is call func
							if ($4->type == FUNCTION_t){
								
								Function* f = (Function*)$4;
								if($1->type != f->returnType && (!($1->type == INT_t  && f->returnType == BYTE_t  )) ){
									errorMismatch(yylineno);
									exit(0);
									}
								
							}
							
							
							var = new Variable($1->type,$2->name);
							var->falselist = $4->falselist;
							var->truelist = $4->truelist;
							var->nextlist = $4->nextlist;
							var->reg = a.Var_Alloc(var->type);
							if ($4->type != FUNCTION_t)
								a.Var_Alloc_And_Assign(var->reg,$1->type,$4);
							else{
								a.Var_Alloc_And_Assign(var->reg,$1->type,$4,&args);
							}
							symbolTable.insertVar(var);
							

							//ask saleh
							$$ = new Node(UNDEFYET_t);
							
						}
				| EnumType ID ASSIGN Exp { 
							
							Variable* var = symbolTable.getVar($2->name);
							Variable* var_as_class = symbolTable.getVar("enum "+$2->name);
							if(var != nullptr || symbolTable.isThereEnumContains($2->name) || var_as_class != nullptr){
							
								errorDef(yylineno, $2->name);
								delete $1;
								delete $2;
								delete $4;
								exit(0);
							}
								
								auto tmp = (Enum_class*)$1;
								auto var_to_assign =symbolTable.getVar($4->name);
								if ((! tmp->contains($4->name)) && !(tmp->contains(var_to_assign->value))   ){
								
									//cout << "tmp->name = " << tmp->name << "  , $4->name = " << $4->name  << "  v_t_a->value = "<< var_to_assign->value << endl;
									errorUndefEnumValue(yylineno,$2->name);
									delete $2;
											
									exit(0);		
								
								}
								//TODO: check if exp is function
								$2->reg  = a.Var_Alloc();
								a.Var_Alloc_And_Assign($2->reg ,INT_t,$4,nullptr);
								
							}
				SC{
								Enum_var* new_var = new Enum_var(ENUM_t, (Enum_class*) $1   ,$2->name,0,$4->value);
										symbolTable.insertVar(new_var);
										new_var->falselist = $4->falselist;
										new_var->truelist = $4->truelist;
										new_var->nextlist = $4->nextlist;
										
										delete $2;
										//ask saleh
							$$ = new Node(UNDEFYET_t);
										
				}	
				| ID ASSIGN Exp SC 													
						{
						
							Variable* var = symbolTable.getVar($1->name);
							if(var == nullptr || var->type == FUNCTION_t ){
								
								errorUndef(yylineno, $2->name);
								delete $1;
								
								exit(0);
							}
							
							if( var->type !=ENUM_t && $3->type != FUNCTION_t && (var->type != $3->type) && (var->type != INT_t && $3->type != BYTE_t)){
						
								errorMismatch(yylineno);
								delete $1;
								
								exit(0);
							}
							//check if exp is call func
							if ($3->type == FUNCTION_t){
								
								Function* f = (Function*)symbolTable.getVar($3->name);
								if(var->type != f->returnType && (!(var->type == INT_t  && f->returnType == BYTE_t  )) ){
								errorMismatch(yylineno);
								exit(0);
								}
								
							}
							if(var->type == ENUM_t && ($3->type == ENUM_t || $3->type == INT_t || $3->type == BYTE_t || $3->type == BOOL_t|| $3->type == STRING_t || $3->type == VOID_t)){
								auto tmp = (Enum_var*)var;
								auto tmp_class = (Enum_class*)symbolTable.getVar(tmp->enum_type);
								auto var_to_assign =symbolTable.getVar($3->name);
								if (tmp_class == nullptr || (!tmp_class->contains($3->name)   &&  !(tmp_class->contains(var_to_assign->value))  )){
									errorUndefEnumValue(yylineno,var->name);
									exit(0);
								}
							}
								var->value = $3->value;
								var->falselist = $3->falselist;
								var->nextlist = $3->nextlist;
								var->truelist = $3->truelist;
								//CodeBuffer::instance().emit("name is " + var->name + "value is " + var->value + "reg is " + var->reg);
							//the name of the func says alloc, but don't worry it doesn't alloc anything
							if ($3->type == FUNCTION_t)
								a.Var_Alloc_And_Assign(var->reg,var->type,$3,&args);
							else if($3->type == ENUM_t){
							
								var->reg = a.Var_Alloc();
								a.Var_Alloc_And_Assign(var->reg ,INT_t,$3,nullptr);
								
							}else{
								a.Var_Alloc_And_Assign(var->reg,var->type,$3);
								}
							
							
							

							delete $1;
							//ask saleh
							$$ = new Node(UNDEFYET_t);
							
						}
				| Call SC 															
						{
						
						}
				| RETURN SC 														
						{
							auto& scope = symbolTable.scopes_table[symbolTable.scopes_table.size()-1 < 0 ? 0 : symbolTable.scopes_table.size()-1 ];
							assert(scope.curFunc != nullptr);//grammar makes sure
							auto f = scope.curFunc;
							if(f->returnType != VOID_t){
								errorMismatch(yylineno);
								exit(0);
							}
							
							a.genReturn(scope.curFunc);
							
							
							return_flag.pop();
							return_flag.push(false);
							//ask saleh
							$$ = new Node(UNDEFYET_t);
						}
				| RETURN Exp SC 													
						{//cout << "return1" << endl;
							auto& scope = symbolTable.scopes_table[symbolTable.scopes_table.size()-1 < 0 ? 0 : symbolTable.scopes_table.size()-1];
							assert(scope.curFunc != nullptr);//grammar makes sure
							auto f = scope.curFunc;
							if($2->type != FUNCTION_t && (f->returnType != $2->type || $2->type == VOID_t) && !(f->returnType == INT_t && $2->type == BYTE_t) ){
								errorMismatch(yylineno);
								delete $2;
								exit(0);
							}
							
							//cout << "return2" << endl;
							
							//check if exp is call func
							if ($2->type == FUNCTION_t){
								
								Function* exp_f = (Function*)$2;
								if(f->returnType != exp_f->returnType && (!(f->returnType == INT_t  && exp_f->returnType == BYTE_t  )) ){
									errorMismatch(yylineno);
									exit(0);
								}
								
							}
							
							a.genReturn(f , $2);
							
							return_flag.pop();
							return_flag.push(false);
							$$ = new Node(UNDEFYET_t);
						}
						
					
				| IF LPAREN checkBoolExp MAKE_IF_BR M RPAREN OPENORMAL  Statement  CLOSE  									
						{
						
						//return_flag.pop();
					
						//{return_flag.push(true);}
						
						//ask saleh
							$$ = new Node(UNDEFYET_t);
						pair<int,BranchLabelIndex> p = pair<int,BranchLabelIndex>(last_br_emit.top(),FIRST);
						pair<int,BranchLabelIndex> p2 = pair<int,BranchLabelIndex>(last_br_emit.top(),SECOND);
						$3->truelist =  CodeBuffer::instance().merge($3->truelist , CodeBuffer::instance().makelist(p));
						$3->falselist =  CodeBuffer::instance().merge($3->falselist , CodeBuffer::instance().makelist(p2));
						
						CodeBuffer::instance().bpatch($3->truelist, $5->reg);
						
						//-------
						$$->nextlist = CodeBuffer::instance().merge($8->nextlist , $3->falselist);
						
						
						int i = CodeBuffer::instance().emit("	br label @");
						string DoneL =  CodeBuffer::instance().genLabel();
						CodeBuffer::instance().bpatch($$->nextlist, DoneL);
						
						
						pair<int,BranchLabelIndex> p3 = pair<int,BranchLabelIndex>(i,FIRST);
						CodeBuffer::instance().bpatch(CodeBuffer::instance().makelist(p3),DoneL);
						
						last_br_emit.pop();
						
						}
				
				
				| IF LPAREN checkBoolExp MAKE_IF_BR M RPAREN OPENORMAL Statement CLOSE ELSE MELSE M OPENORMAL Statement CLOSE
						{
						
						//ask saleh
							$$ = new Node(UNDEFYET_t);
						pair<int,BranchLabelIndex> p = pair<int,BranchLabelIndex>(last_br_emit.top(),FIRST);
						pair<int,BranchLabelIndex> p2 = pair<int,BranchLabelIndex>(last_br_emit.top(),SECOND);
						$3->truelist =  CodeBuffer::instance().merge($3->truelist , CodeBuffer::instance().makelist(p));
						$3->falselist =  CodeBuffer::instance().merge($3->falselist , CodeBuffer::instance().makelist(p2));
						
						
						CodeBuffer::instance().bpatch($3->truelist, $5->reg);
						CodeBuffer::instance().bpatch($3->falselist, $12->reg);
						
						//--------
						
						$$->nextlist = CodeBuffer::instance().merge($8->nextlist , $14->nextlist);//after done from true body, and false body
						$$->nextlist = CodeBuffer::instance().merge($$->nextlist , CodeBuffer::instance().makelist(last_MELSE.top()));//add to it the nextlist of MELSE
						
						
						int i = CodeBuffer::instance().emit("	br label @");//doneLabel after the else body
						string DoneL =  CodeBuffer::instance().genLabel();
						
						
						CodeBuffer::instance().bpatch($$->nextlist, DoneL);
						pair<int,BranchLabelIndex> p3 = pair<int,BranchLabelIndex>(i,FIRST);
						
						auto doneList = CodeBuffer::instance().makelist(p3);
						//doneList = CodeBuffer::instance().merge(doneList, $11->nextlist);
						
						CodeBuffer::instance().bpatch(doneList ,DoneL);
						
						last_br_emit.pop();
						}
				
			
				| MAKE_WHILE WHILE LPAREN M checkBoolExp  MAKE_IF_BR  M OPENLOOP RPAREN  Statement 									
				{
					
					//TODO ask salih for this
					$$ = new Node(UNDEFYET_t);
					pair<int,BranchLabelIndex> p_while = pair<int,BranchLabelIndex>(last_while_emit.top(),FIRST);
					
					
					last_while_emit.pop();
					CodeBuffer::instance().bpatch( CodeBuffer::instance().makelist(p_while), $4->reg);
					
				
					
					pair<int,BranchLabelIndex> p = pair<int,BranchLabelIndex>(last_br_emit.top(),FIRST);
					
					pair<int,BranchLabelIndex> p2 = pair<int,BranchLabelIndex>(last_br_emit.top(),SECOND);
					
					$5->truelist =  CodeBuffer::instance().merge($5->truelist , CodeBuffer::instance().makelist(p));
					
					
					$5->falselist =  CodeBuffer::instance().merge($5->falselist , CodeBuffer::instance().makelist(p2));
					
				//	cout << "here" << endl;
				//	cout << "here " << $$->type<< endl;
				//	cout << "here " << $$->nextlist.size()<< endl;
					$$->nextlist = CodeBuffer::instance().merge($$->nextlist, $5->falselist);
					$$->nextlist = CodeBuffer::instance().merge($$->nextlist, Break_labels.top());
				//	cout << "here " << $$->type<< endl;
					
					
					$$->nextlist = CodeBuffer::instance().merge($$->nextlist, $10->nextlist);
					
					CodeBuffer::instance().bpatch($5->truelist, $7->reg);
					
					

					
					
					int i = CodeBuffer::instance().emit("	br label @");
					pair<int,BranchLabelIndex> p3 = pair<int,BranchLabelIndex>(i,FIRST);
					string DoneL = CodeBuffer::instance().genLabel();
					CodeBuffer::instance().bpatch(CodeBuffer::instance().makelist(p3),$4->reg);
					CodeBuffer::instance().bpatch(Cont_labels.top(), $4->reg);
					
					CodeBuffer::instance().bpatch($$->nextlist, DoneL);
					
					
					
                    symbolTable.closeScope();
					last_br_emit.pop();
					Break_labels.pop();
					Cont_labels.pop();
					return_flag.pop();
				}
						 
						
						
				| BREAK SC 															
						{
							//ask saleh
							$$ = new Node(UNDEFYET_t);
							auto& scope = symbolTable.scopes_table[symbolTable.scopes_table.size()-1 < 0 ? 0 : symbolTable.scopes_table.size()-1];
							if(!scope.isLoop){
								errorUnexpectedBreak(yylineno);
								exit(0);
							}
							
							//TODO: add nextlist code for it?
							int i = CodeBuffer::instance().emit("	br label @");
							a.RegAlloc();//something about labels ,, llvm sucks
							pair<int,BranchLabelIndex> p = pair<int,BranchLabelIndex> ( i, FIRST);
							Break_labels.top().push_back(p);
				
							
						}
				| CONTINUE SC 														
						{
							//ask saleh
							$$ = new Node(UNDEFYET_t);
							auto& scope = symbolTable.scopes_table[symbolTable.scopes_table.size()-1 < 0 ? 0 : symbolTable.scopes_table.size()-1];
							if(!scope.isLoop){
								errorUnexpectedContinue(yylineno);
								exit(0);
							}
							//TODO: add nextlist code for it?
							int i = CodeBuffer::instance().emit("	br label @");
							a.RegAlloc();//something about labels ,, llvm sucks
							pair<int,BranchLabelIndex> p = pair<int,BranchLabelIndex> ( i, FIRST);
							Cont_labels.top().push_back(p);
						};

Call :			ID LPAREN {ParamListStack.push(vector<Node*>()); } ExpList RPAREN 										
						{
							
						
							Function* callee = (Function*)symbolTable.getVar($1->name);
							auto& vec = ParamListStack.top();


							if (callee == nullptr || callee->type != FUNCTION_t){
								
								errorUndefFunc(yylineno, $1->name);
								ParamListStack.pop();
								delete $1;
								exit(0);
							}
							delete $1;
							
							callee->ValidateParameters(vec,symbolTable);
							
							args = vec;
							
							
							callee->reg = a.genCall(callee->name,callee->returnType,callee->paramTypes,args);
							//$$ = callee;
							//CodeBuffer::instance().emit("callee->name " + callee->name + " , calle reg " + callee->reg);
							$$ = new Node(callee->returnType , "" , "" , callee->reg);
							$$->is_Var = true;
							
							
							ParamListStack.pop();
							
						}

				| ID LPAREN RPAREN 													
						{	
							Function* callee = (Function*)symbolTable.getVar($1->name);
							auto vec = vector<Node*>();
							
							
							if (callee == nullptr || callee->type != FUNCTION_t){
								
								errorUndefFunc(yylineno, $1->name);
								delete $1;
								exit(0);
							}

							delete $1;
							
							
							//$$ = callee;
							args=vec;
							
							callee->ValidateParameters(vec,symbolTable);
							callee->reg = a.genCall(callee->name,callee->returnType,callee->paramTypes,args);
							$$ = new Node(callee->returnType , "" , "" , callee->reg);
							$$->is_Var = true;
							
							
						};

ExpList :		Exp 														
						{ParamListStack.top().push_back($1);}
				| Exp COMMA ExpList 												
						{ParamListStack.top().push_back($1);};

Type :			INT 															
						{
						
					
						$$ = new Node(INT_t);}
				| BYTE 																
						{$$ = new Node(BYTE_t);}
				| BOOL 																
						{
						
						$$ = new Node(BOOL_t);};

EnumType :		ENUM ID 													
						{Node* var = symbolTable.getVar("enum " + $2->name);
							if (var == nullptr){
								errorUndefEnum(yylineno, $2->name);
								delete $2;
								exit(0);
							}
							delete $2;
							$$ = var;
						};
						

Exp :			LPAREN Exp RPAREN 											
						{$$ = $2;}

				| Exp ADDOPS Exp 													
						{
						
						//cout << "here" << endl;;
						TokenType old1 = $1->type, old2 = $3->type;
						if($1->type == FUNCTION_t)
							$1->type = ((Function*) $1)->returnType;
						if($3->type == FUNCTION_t)
							$3->type = ((Function*) $3)->returnType;
						
						

						if (($1->type != INT_t && $1->type !=BYTE_t) || ($3->type != INT_t && $3->type != BYTE_t)){
							errorMismatch(yylineno);
							delete $1;
							delete $3;
							exit(0);
						}
						if ($1->type == BYTE_t && $3->type == BYTE_t){
							
							$$ = new Node(BYTE_t);
							$$->is_Var = true;
							
							
							$1->type = old1;
							$3->type = old2;	
							$$->reg = a.genAddOp($1,$3,$2->value,BYTE_t);
						}
						else{ 
							
							
							$$= new Node(INT_t);
							//its valued is save in an allocated place , so we need that.
							$$->is_Var = true;
							
							$1->type = old1;
							$3->type = old2;	
							
							
							//cout << "$1->reg = " << $1->reg << ",   $3->reg = " << $3->reg << endl;
							$$->reg = a.genAddOp($1,$3,$2->value);
							}
							//cout << "end for all" <<endl;
						}
				| Exp MULTOPS Exp 			
						{
						TokenType old1 = $1->type, old2 = $3->type;
						if($1->type == FUNCTION_t)
							$1->type = ((Function*) $1)->returnType;
						if($3->type == FUNCTION_t)
							$3->type = ((Function*) $3)->returnType;

				
						 if (($1->type != INT_t && $1->type !=BYTE_t) || ($3->type != INT_t && $3->type != BYTE_t)){
							errorMismatch(yylineno);
							delete $1;
							delete $3;
							exit(0);
						}
						
						
						if($2->value == "/"){
							a.CheckDivZero($3);
						}
						if ($1->type == BYTE_t && $3->type == BYTE_t){
							
							$$ = new Node(BYTE_t);
							$$->is_Var = true;
							
							$1->type = old1;
							$3->type = old2;	
							$$->reg = a.genAddOp($1,$3,$2->value,BYTE_t);
						}
						else{ 
							$$= new Node(INT_t);
							//its valued is save in an allocated place , so we need that.
							$$->is_Var = true;
							
							$1->type = old1;
							$3->type = old2;	
							$$->reg = a.genAddOp($1,$3,$2->value);
							}

						}

				| ID 																
					{
					Variable* var = symbolTable.getVar($1->name);
							if(  var == nullptr ){
							
								if (!symbolTable.isThereEnumContains($1->name)){
								
								errorUndef(yylineno, $1->name);
								delete $1;
								exit(0);
								}
							}
							
						if (symbolTable.isThereEnumContains($1->name) && var == nullptr){

							auto tmp = symbolTable.FindEnumContains($1->name);//we know this isn't nullptr for sure
							string enum_reg = a.Var_Alloc();
							$$ = new Enum_var(ENUM_t,  tmp,  $1->name,0,$1->name,enum_reg);
							int ordered_num = get_enum_valued_order( (Enum_var*) $$);	
							CodeBuffer::instance().emit("	store i32 " + to_string(ordered_num) + " , i32* " + enum_reg);
							
							//TODO: add emit code for enum case, if needed(im guessing yes needed)
						}
						else{
							$$ = var;
						}
						
						
					}

				| Call 																
					{
						
						
						Function* callee = (Function*)$1;
						$$ = $1;
						
						
						//a.Var_Alloc_And_Assign($$->reg,callee->returnType,callee,&args);
						
						
						//a.genCall(callee->name,callee->returnType,callee->paramTypes,args,true);
						//$$ = new Node( ((Function*)$1)->returnType , "" , callee->value , a.RegAlloc());
						
						
						
						
						
					}

				| NUM 																
						{ 
						//no need here for Var_Alloc
						$$ = new Node(INT_t , $1->name , $1->value);
						
							delete $1;
						}

				| NUM B 														
					{	if( !( stoi($1->value) >= 0 && (stoi($1->value) <= 255))){
										
											errorByteTooLarge(yylineno, $1->value);
											delete $1;
											exit(0);
										}
						$$ = new Node(BYTE_t,$1->name,$1->value, $1->value);
						delete $1;

					}

				| STRING 															
						{
							$$ = new Node(STRING_t,$1->name,$1->name); 
							//might not need this anyways but TODO: no need to do emit code? emitGlobal? what the fuck?
						}

				| TRUE 																
						{
						
							$$ = new Node(BOOL_t,"","true", a.RegAlloc());
							//$$->is_Var = true;
							a.genBool($$);
						
						}

				| FALSE 															
						{
							$$ = new Node(BOOL_t,"","false", a.RegAlloc());
							//$$->is_Var = true;
							a.genBool($$);
						}
						
				| NOT checkBoolExp 															
						{
							
						
							string my_reg = a.RegAlloc();
							$$ = new Node(BOOL_t , "" , "",my_reg);
							$$->is_Var = $2->is_Var;//check this $2->is_Var;
							
							if (!($2->is_Var)){
								$$->value = $2->value == "true" ? "false" : "true";
								
							}else{
								$$->truelist = $2->falselist;
								$$->falselist = $2->truelist;
							}
							
							//TODO: fix this
							a.genBool($$,$2->reg, true);
						}


				| checkBoolExp AND MAKE_IF_BR M checkBoolExp ANDGEN M 												
						{
						
							auto last_br = last_br_emit.top();
							last_br_emit.pop();
							
							
							
							pair<int,BranchLabelIndex> p = pair<int,BranchLabelIndex>(last_br,FIRST);
							pair<int,BranchLabelIndex> p2 = pair<int,BranchLabelIndex>(last_br,SECOND);
							auto last_br_true =  CodeBuffer::instance().makelist(p);
							auto last_br_false =  CodeBuffer::instance().makelist(p2);
							
							
								
								
								
							//frist if br
						
													

							
							CodeBuffer::instance().bpatch($1->truelist,$4->reg);
							CodeBuffer::instance().bpatch($6->nextlist,$7->reg);
							CodeBuffer::instance().bpatch(last_br_true,$4->reg);
							//CodeBuffer::instance().bpatch(last_br_false,$7->reg);
							
							
							$$ = new Node(BOOL_t , "" ,"",a.RegAlloc());
							$$->is_Var = true;
							
							if (!($5->is_Var)){
								$$->value = $5->value;
								
							}
							
							//TODO: fix this
							a.genBool($$,$5->reg);
							
							
							$$->falselist = CodeBuffer::instance().merge($1->falselist,$5->falselist);
							$$->falselist = CodeBuffer::instance().merge($$->falselist,last_br_false);
							
							$$->truelist = $5->truelist;
							$$->nextlist = $5->nextlist;
						
							
							

						}

				| checkBoolExp OR MAKE_IF_BR M checkBoolExp ANDGEN M 												
						{
							
							
							
							auto last_br = last_br_emit.top();
							last_br_emit.pop();
							
					
							pair<int,BranchLabelIndex> p = pair<int,BranchLabelIndex>(last_br,FIRST);
							pair<int,BranchLabelIndex> p2 = pair<int,BranchLabelIndex>(last_br,SECOND);
							auto last_br_true =  CodeBuffer::instance().makelist(p);
							auto last_br_false =  CodeBuffer::instance().makelist(p2);
							
					
							
							CodeBuffer::instance().bpatch($1->falselist,$4->reg);
							//CodeBuffer::instance().bpatch(last_br_true,$7->reg);
							
							CodeBuffer::instance().bpatch($6->nextlist,$7->reg);
							CodeBuffer::instance().bpatch(last_br_false,$4->reg);
	
							
							
							$$ = new Node(BOOL_t , "" ,"",a.RegAlloc());
							$$->is_Var = true;
							
							if (!($5->is_Var)){
								$$->value = $5->value;
								
							}
							
							//TODO: fix this
							a.genBool($$,$5->reg);
						//	CodeBuffer::instance().emit("r2->reg is " + $5->reg);
							
							
							$$->truelist = CodeBuffer::instance().merge($1->truelist,$5->truelist);
							$$->truelist = CodeBuffer::instance().merge($$->truelist,last_br_true); 
							
							$$->falselist = $5->falselist;
							$$->nextlist = $5->nextlist;
						
							
							
							

						}

				| Exp RELATIONOP Exp 												
						{
							
							TokenType old1 = $1->type, old2 = $3->type;
							if($1->type == FUNCTION_t)
								$1->type = ((Function*) $1)->returnType;
							if($3->type == FUNCTION_t)
								$3->type = ((Function*) $3)->returnType;
							
							
							if( ($1->type != INT_t && $1->type != BYTE_t) || ($3->type != INT_t && $3->type != BYTE_t)){
									errorMismatch(yylineno);
									delete $1;
									delete $3;
									exit(0);
							}
							
							$$ = new Node(BOOL_t);
							$$->is_Var = true;
								
							$1->type = old1;
							$3->type = old2;
							
							$$->reg = a.genBoolFromRelOp($1,$3,$2->value, &($$->value));
						}

				| Exp EQUALOP Exp 													
						{
						
							TokenType old1 = $1->type, old2 = $3->type;
							if($1->type == FUNCTION_t)
								$1->type = ((Function*) $1)->returnType;
							if($3->type == FUNCTION_t)
								$3->type = ((Function*) $3)->returnType;
							
							if(($1->type != INT_t && $1->type != BYTE_t) || ($3->type != INT_t && $3->type != BYTE_t)){
									errorMismatch(yylineno);
									
									delete $1;
									delete $3;
									exit(0);
							}
							$$ = new Node(BOOL_t);
							$$->is_Var = true;
							
							$1->type = old1;
							$3->type = old2;
							
							$$->reg = a.genBoolFromRelOp($1,$3,$2->value, &($$->value));
						}

				| LPAREN Type RPAREN Exp 
				
						{	
						if ( $2->type != INT_t){
								delete $2;
								errorMismatch(yylineno);
								exit(0);
								}
						
						
						//TODO: fix situation where EXP is a function call , no need cuz funcs doesnt return enum
						
							
							if($4->type != ENUM_t && !(symbolTable.isThereEnumContains($4->name))){
								delete $2;
								
								errorMismatch(yylineno);
								exit(0);
							}
							
							Node* enum_var = symbolTable.getVar($4->name);
							if (enum_var == nullptr && !(symbolTable.isThereEnumContains($4->name))){
								delete $2;
								
								errorUndef(yylineno,$4->name);
								exit(0);
							}
							
							auto enum_var_casted = enum_var==nullptr ? nullptr : (Enum_var*)enum_var; 
							string enum_var_name = enum_var==nullptr ? "" : enum_var_casted->name;
							int enum_var_offset = enum_var==nullptr ? 0 : enum_var_casted->offset; 
							string enum_var_value = enum_var==nullptr ? "" : enum_var_casted->value; 
							Variable* new_int = new Variable(INT_t,enum_var_name,enum_var_offset,enum_var_value);
							delete $2;
							$$ = new_int;
							
							
							//Enum_class* enum_class = symbolTable.FindEnumContains(enum_var->value);
							
							//if ($4->is_Var){
							//string tmp_reg = a.RegAlloc();
							//CodeBuffer::instance().emit("	"+tmp_reg + " = load i32 , i32* " + $4->reg);
							//$$->reg = a.Var_Alloc();
							//CodeBuffer::instance().emit("	store i32 " + tmp_reg + " , i32* " + $$->reg);
							//}else{
							$$->reg = a.Var_Alloc();
							a.Var_Alloc_And_Assign($$->reg ,INT_t,enum_var,nullptr);
							//}
							
						};
						
						
checkBoolExp :     Exp {
						TokenType old1 = $1->type;
						if($1->type == FUNCTION_t)
							$1->type = ((Function*) $1)->returnType;

						
						if($1->type != BOOL_t)
						{
							errorMismatch(yylineno);
							exit(0);
						}
						
						$1->type = old1;
						last_bool_exp = $1;
						$$ = $1;

					}
					
OPENORMAL:					{
								symbolTable.openScope(NORMAL);
								return_flag.push(true);//for new if/while scope
							};
							
OPENLOOP:					{
								symbolTable.openScope(LOOP);
								return_flag.push(true);//for new if/while scope
							};
CLOSE:						{
								symbolTable.closeScope();
								return_flag.pop();
							};




MAKE_WHILE:				{
							last_while_emit.push( CodeBuffer::instance().emit("	br label @") );
							auto break_vec = vector< pair<int,BranchLabelIndex>>();
							Break_labels.push(break_vec);
							auto cont_vec = vector< pair<int,BranchLabelIndex>>();
							Cont_labels.push(cont_vec);
						}	
MAKE_IF_BR:				{
							last_br_emit.push( a.genIF(last_bool_exp) );
						}
			
M:      				{
							$$ = new Node( UNDEFYET_t,"" ,"",   CodeBuffer::instance().genLabel());//saves the label in reg
						}
MELSE:					{
						//this one makes sure that if we are in the if body (the if cond is true) and there is an else body, we use this to skip the else body
						
						
							$$ = new Node(UNDEFYET_t, ""); 
							
							int i = CodeBuffer::instance().emit("	br label @");
							pair<int,BranchLabelIndex> p = pair<int,BranchLabelIndex> ( i, FIRST);
							auto l = CodeBuffer::instance().makelist(p);
							$$->nextlist = l;
							
							last_MELSE.push(p);
						}
ANDGEN:					{
							$$ = new Node(UNDEFYET_t, ""); 
							
							int i = CodeBuffer::instance().emit("	br label @");
							pair<int,BranchLabelIndex> p = pair<int,BranchLabelIndex> ( i, FIRST);
							auto l = CodeBuffer::instance().makelist(p);
							$$->nextlist = l;
							
							
						}
%%



int main()
{

	symbolTable.openScope(GLOBAL);
	curFunc = new Function("print", VOID_t);
	Variable* dummy = new Variable(STRING_t);
	curFunc->addParam(dummy);
	symbolTable.insertFunc(curFunc);
	symbolTable.scopes_table.pop_back();
	symbolTable.offset_stack.pop();
	
	curFunc = new Function("printi", VOID_t);
	dummy = new Variable(INT_t,"");
	curFunc->addParam(dummy);
	symbolTable.insertFunc(curFunc);
	symbolTable.scopes_table.pop_back();
	symbolTable.offset_stack.pop();
	a.Gen_Printers();
	
	
	
	yyparse();
	
	
	
	/*checking if main exsists*/
	Function* main_func = (Function*)symbolTable.getVar("main");
	if (main_func == nullptr || main_func->type != FUNCTION_t || main_func->paramTypes.size()!= 0 || main_func->returnType != VOID_t){
		errorMainMissing();
		return 0;
	}
	
	symbolTable.closeScope();
	CodeBuffer::instance().printCodeBuffer();

	

    return 0;
}

void yyerror(char const* error){
	errorSyn(yylineno);
	exit(0);
}





